<!DOCTYPE html>
<html>
<head>
    <title>Updated Platformer Game</title>
    <style>
        canvas {
            background-color: #88B4E0; /* Light blue background */
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="400"></canvas>
    <canvas id="graphCanvas" width="400" height="400"></canvas>
    <script>
    class Sprite {
        constructor(imageSrc, width, height, numFrames, x, y, offsetX, offsetY, canvas) {
            this.canvas = canvas;
            this.ctx = this.canvas.getContext("2d");
            this.spriteImage = new Image();
            this.spriteImage.src = imageSrc;
            this.spriteWidth = width;
            this.spriteHeight = height;
            this.numFrames = numFrames;
            this.currentFrame = 0;
            this.animationId = null;
            this.mode = "stopped";
            this.x = x; // Initial x coordinate
            this.y = y; // Initial y coordinate
            this.offsetX = offsetX; // X offset for the sprite within the image
            this.offsetY = offsetY; // Y offset for the sprite within the image
            this.flipSprite = false;
            this.interval = false;
            this.animationsSpeed = 15;
            this.spriteImage.onload = () => {
                //this.drawFrame(this.currentFrame, 0);
            };
        }

        drawFrame(frameX, frameY) {
            this.ctx.clearRect(0, 0, this.spriteWidth, this.spriteHeight);
            
            if (this.flipSprite == true) {
                ctx.save();
                ctx.scale(-1, 1);
            }
            this.ctx.drawImage(
                this.spriteImage,
                (frameX * this.spriteWidth) + this.offsetX,
                frameY * this.spriteHeight + this.offsetY,
                this.spriteWidth,
                this.spriteHeight,
                this.x * (this.flipSprite ? -1: 1), // X coordinate
                this.y, // Y coordinate
                40 * (this.flipSprite ? -1: 1),
                55);

            this.ctx.restore();
        }



        draw() {

            if (this.mode === "running") {
                if (this.interval == false) {
                this.interval = setInterval(() => {
                    this.currentFrame = (this.currentFrame + 1) % this.numFrames;
                }, 1000 / this.animationsSpeed);
                }
                this.drawFrame(this.currentFrame, 0);

            } else {
                clearInterval(this.interval);
                this.interval = false;
                this.currentFrame = 0;
                this.drawFrame(0, 0);
            }

        }

        start() {
            if (this.mode !== "running") {
                this.mode = "running";
                this.update();
            }
        }

        stop() {
            if (this.mode !== "stopped") {
                this.mode = "stopped";
                cancelAnimationFrame(this.animationId);
                this.drawFrame(0, 0);
            }
        }
    }

    class NeuralNetworkVisualization {
        constructor(layers, NN, canvas) {
            this.NN = NN;
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.nodeRadius = 20;
            this.nodeSpacing = 30;
        }

        drawNode(x, y, value) {
            this.ctx.beginPath();
            this.ctx.arc(x, y, this.nodeRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = 'white';
            this.ctx.fill();
            this.ctx.lineWidth = 2;
            this.ctx.strokeStyle = 'black';
            this.ctx.stroke();
            this.ctx.fillStyle = 'black';
            this.ctx.font = 'bold 14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.textBaseline = 'middle';
            //this.ctx.fillText(value.toFixed(2), x, y);
        }

        drawConnection(x1, y1, x2, y2, weight) {
            const lineWidth = Math.abs(weight) * 5; // Adjust the scale for line weight
            this.ctx.lineWidth = lineWidth;
            this.ctx.strokeStyle = weight > 0 ? 'green' : 'red';
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
        }

        drawNeuralNetwork() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            for (let i = 0; i < this.NN.layers.length; i++) {
                const nodesInLayer = this.NN.layers[i];
                const x = this.nodeSpacing * (i + 1);

                for (let j = 0; j < nodesInLayer; j++) {
                    const y = (this.canvas.height / 2) - ((nodesInLayer - 1) * this.nodeSpacing) / 2 + j * this.nodeSpacing;

                    const value = (i === 0) ? '0' : '1'; 

                    this.drawNode(x, y, value);

                    if (i > 1) {
                        const prevNodes = this.NN.layers[i - 1];
                        const prevX = this.nodeSpacing * i - this.nodeSpacing / 2;
                        for (let k = 0; k < prevNodes; k++) {
                            const prevY = (this.canvas.height / 2) - ((prevNodes - 1) * this.nodeSpacing) / 2 + k * this.nodeSpacing;
                            const weight = this.NN.weights[i - 2][k][j];
                            this.drawConnection(prevX, prevY, x, y, weight);
                        }
                    }
                }
            }
        }
    }

class NeuralNetwork {
            constructor(layers) {
                this.layers = layers;
                this.weights = [];
                this.biases = [];
                this.initializeWeightsAndBiases();
            }

            initializeWeightsAndBiases() {
                for (let i = 1; i < this.layers.length; i++) {
                    const prevLayerNodes = this.layers[i - 1];
                    const currentLayerNodes = this.layers[i];

            const weightMatrix = new Array(currentLayerNodes).fill(null).map(() =>
                new Array(prevLayerNodes).fill(0).map(() => Math.random() * 2 - 1)
            );

                    this.weights.push(weightMatrix);

                    const biasVector = new Array(currentLayerNodes).fill(0).map(() => Math.random() * 2 - 1);
                    this.biases.push(biasVector);
                }
            }

            lerplearn (cpu) {

                const lerpFactor = 0.2; // Adjust as needed

                for (let i = 0; i < this.weights.length; i++) {
                    for (let j = 0; j < this.weights[i].length; j++) {
                        for (let k = 0; k < this.weights[i][j].length; k++) {
                            this.weights[i][j][k] = cpu.weights[i][j][k] + lerpFactor * (Math.random() - 0.5);
                        }
                    }
                }
                for (let i = 0; i < this.biases.length; i++) {
                    for (let j = 0; j < this.biases[i].length; j++) {
                            this.biases[i][j] = cpu.biases[i][j] + lerpFactor * (Math.random() - 0.5);
                    }
                }

            }

            propagate(inputs) {
                let prevLayerOutput = inputs;

                for (let i = 0; i < this.layers.length - 1; i++) {
                    const layerWeights = this.weights[i];
                    const layerBiases = this.biases[i];

                    const nextLayerNodes = this.layers[i + 1];
                    const nextLayerOutput = new Array(nextLayerNodes).fill(0);

                    for (let j = 0; j < nextLayerNodes; j++) {
                        let nodeOutput = 0;
                        for (let k = 0; k < prevLayerOutput.length; k++) {
                            nodeOutput += prevLayerOutput[k] * layerWeights[j][k];
                        }
                        nodeOutput += layerBiases[j];
                        nextLayerOutput[j] = nodeOutput;
                    }

                    // Apply activation function (step function) - output > 0.5 becomes 1, else 0
                    for (let j = 0; j < nextLayerOutput.length; j++) {
                        nextLayerOutput[j] = nextLayerOutput[j] > 0.5 ? 1 : 0;
                    }

                    prevLayerOutput = nextLayerOutput;
                }

                return prevLayerOutput; // Output of the last layer
            }
        }
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 53;
                this.velocityX = 0;
                this.velocityY = 0;
                this.friction = 0.8; // Reduced friction value
                this.gravity = 0.4;
                this.jumping = false;

                this.sprite = new Sprite("data:image/png;base64,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", 100, 175, 4, this.x, this.y, 0, 175, canvas);

            }

            update() {
                // Apply friction only if no left or right arrow key is pressed
                if (!keys['ArrowLeft'] && !keys['ArrowRight']) {
                    this.velocityX *= this.friction;
                }

                // Apply gravity
                this.velocityY += this.gravity;

                // Jump
                if (this.jumping && this.y + this.height >= canvas.height - groundHeight) {
                    this.velocityY = -10; // Adjust the jump strength
                    //this.jumping = false;
                }

                // Move the player based on velocity
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Keep the player within the canvas bounds
                if (this.x < 0) {
                    this.x = 0;
                }

                if (this.y + this.height > canvas.height - groundHeight) {
                    this.y = canvas.height - groundHeight - this.height;
                    this.velocityY = 0;
                    this.jumping = false;
                }
            }

            draw(ctx) {

                this.sprite.x = this.x - screenX;
                this.sprite.y = this.y;

                if (this.jumping) {
                    
                    this.sprite.offsetY = 0;
                    this.sprite.offsetX = 300;

                    //this.sprite.numFrames = 5;
                    this.sprite.mode = "stopped";
                    //this.sprite.loop = false;
                } else {

                    this.sprite.offsetY = 175;
                    this.sprite.offsetX = 0;

                    if (this.velocityX  > 3.5) {
                        this.sprite.flipSprite = false;
                        this.sprite.mode = 'running';
                    } else if(this.velocityX < -3.5) {
                        this.sprite.flipSprite = true;
                        this.sprite.mode = 'running';
                    } else {
                        this.sprite.mode = 'stopped';
                    }

                    
                }

                this.sprite.draw();


                //ctx.fillStyle = 'red';
                //ctx.fillRect(this.x - screenX, this.y, this.width, this.height);
            }
        }

        class GameElement {
            constructor(x, y, width, height, color) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - screenX, this.y, this.width, this.height);
            }
        }

class CPU {
    constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.velocityX = 0;
        this.velocityY = 0;
        this.friction = 0.8; // Reduced friction value
        this.gravity = 0.4;
        this.jumping = false;
        this.randomMoveTimer = 0;
        this.cleft = false;
        this.cright = false;
        this.cjump = false;
        this.brain = new NeuralNetwork(layers);
    }

    getRayIntersections() {
        const rayCount = 12; // Number of rays
        const rayLength = 100; // Length of each ray

        const intersections = [];

        for (let i = 0; i < rayCount; i++) {
            const angle = (i / rayCount) * (2 * Math.PI);
            const rayEndpointX = this.x + rayLength * Math.cos(angle);
            const rayEndpointY = this.y + rayLength * Math.sin(angle);
            let nearestIntersection = rayLength;
            let intersectionPoint = { x: rayEndpointX, y: rayEndpointY };

            for (const wall of walls) {
                const intersection = this.getIntersectionPoint(this.x, this.y, rayEndpointX, rayEndpointY, wall);

                if (intersection) {
                    const dx = intersection.x - this.x;
                    const dy = intersection.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < nearestIntersection) {
                        nearestIntersection = distance;
                        intersectionPoint = intersection;
                    }
                }
            }

            intersections.push(nearestIntersection / rayLength);
        }

        return intersections;
    }

    getIntersectionPoint(x1, y1, x2, y2, wall) {
        const x3 = wall.x;
        const y3 = wall.y;
        const x4 = wall.x + wall.width;
        const y4 = wall.y + wall.height;

        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (denominator === 0) {
            return null;
        }

        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

        if (t > 0 && t < 1 && u > 0) {
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }

        return null;
    }

    // Rest of the CPU class


    update() {
        // Apply gravity
        this.velocityY += 0.4;

        // Randomly select left, right, or jump
        //this.randomMoveTimer -= 1;
        //if (this.randomMoveTimer <= 0) {
        /**   const randomAction = Math.floor(Math.random() * 3); // 0 for left, 1 for right, 2 for jump
            if (randomAction === 0) {
                this.velocityX = -2; // Move left
            } else if (randomAction === 1) {
                this.velocityX = 2; // Move right
            } else {
                // Jump if the CPU is on the ground
                if (this.y + this.height >= canvas.height - groundHeight) {
                    this.velocityY = -8; // Adjust the jump strength
                    this.jumping = true;
                }
            }

            this.randomMoveTimer = Math.floor(Math.random() * 60) + 30; // Random time between actions
        } **/

        const inputs = this.getRayIntersections();
        const outputs = this.brain.propagate(inputs);

        this.brain.inputs = inputs;
        this.brain.outputs = outputs;

        if (outputs[0] == 1) {
            //JUMP
            if (this.y + this.height >= canvas.height - groundHeight) {
                this.velocityY = -10; // Adjust the jump strength
                this.jumping = true;
            }
        }

        if (outputs[1] == 1) {
            //Left
            this.velocityX = -2; // Move left
        }
        if (outputs[2] == 1) {
            //Right
            this.velocityX = 2; // Move right
        }

        //console.table(inputs);
        //console.table(outputs);




        // Move the CPU character based on velocity
        this.x += this.velocityX;
        this.y += this.velocityY;

        // Bounce off the ground
        if (this.y + this.height > canvas.height - groundHeight) {
            this.y = canvas.height - groundHeight - this.height;
            this.velocityY = 0;
            this.jumping = false;
        }

        // Wrap around when reaching canvas boundaries
        if (this.x < 0) {
            this.x = 0;
        } else if (this.x > canvas.width) {
            //this.x = 0;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - screenX, this.y, this.width, this.height);
        }
}

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Define ground height
        const groundHeight = 20;

        // Create a simple ground object
        const ground = new GameElement(0, canvas.height - groundHeight, 10000, groundHeight, '#5C4033'); // Brown color

        // Create an array to store walls
        const walls = [];
        let bestcpu;

        // Create an array to store CPU characters
        const layers = [12, 8, 6, 3]; // Define the neural network layers [input, hidden1, hidden2, output]
        const cpus = [];
        for (let i = 0; i < 1000; i++) {
            const x = 100;
            const y = canvas.height - groundHeight - 40;
            const width = 40;
            const height = 40;
            const color = 'rgba(0, 0, 255, 0.2)';
            const cpu = new CPU(x, y, width, height, color);
            cpus.push(cpu);
            bestcpu = cpu;
        }

        // Create an instance of NNOutputGraph
        const NNVis = new NeuralNetworkVisualization( layers, bestcpu.brain, document.getElementById('graphCanvas'));

        // Start graphing the neural network output
 

        // Create the player
        const player = new Player(50, canvas.height - groundHeight - 40);

        // Initialize player position
        let playerStartX = player.x;

        // Create a variable to track the screen position
        let screenX = 0;

        // Keyboard input handling
        const keys = {};

        document.addEventListener('keydown', (event) => {
            keys[event.key] = true;

            // Move the player left when the left arrow key is pressed
            if (event.key === 'ArrowLeft') {
                player.velocityX = -4;
            }

            // Move the player right when the right arrow key is pressed
            if (event.key === 'ArrowRight') {
                player.velocityX = 4;
            }

            // Jump when the 'Up' arrow key is pressed
            if (event.key === 'ArrowUp' && player.y + player.height >= canvas.height - groundHeight) {
                player.jumping = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Function to generate a random wall
        function generateRandomWall(x) {
            const height = Math.random() * 70 + 20;
            const grayShade = Math.floor(Math.random() * 156) + 100; // Random gray shade between 100 and 255
            const color = `rgb(${grayShade}, ${grayShade}, ${grayShade})`;
            const wall = new GameElement(x, canvas.height - groundHeight - height, 20, height, color);
            walls.push(wall);
        }

        // Function to update the game elements
        function updateGameElements() {
            player.update();

            // Check for collisions with walls
            walls.forEach((wall) => {
                if (isColliding(player, wall)) {
                    // Reset player position
                    player.x = playerStartX;
                    player.y = canvas.height - groundHeight - player.height;
                    player.velocityX = 0;
                    player.velocityY = 0;
                    screenX = 0;
                }
                cpus.forEach((cpu) => {
                    if (isColliding(cpu, wall)) {

                        if (cpu != bestcpu) {
                            cpu.brain.lerplearn(bestcpu.brain);
                        } else {
                            console.log('best brain died');
                            const randomAction = Math.floor(Math.random() * 3); // 0 for left, 1 for right, 2 for jump
                            if (randomAction === 0) {
                                cpu.brain.lerplearn(bestcpu.brain);

                            }
                        }
                        // Reset player position
                        cpu.x = playerStartX;
                        cpu.y = canvas.height - groundHeight - player.height;
                        cpu.velocityX = 0;
                        cpu.velocityY = 0;

                    }
                });
                wall.draw(ctx);
            });

            // Remove walls that are off-screen and generate new ones
            maxScreenX = screenX + canvas.width;
            //while (walls.length > 0 && walls[0].x + 20 < screenX) {
                //walls.shift();
            //}

            while (walls.length === 0 || walls[walls.length - 1].x + 20 < maxScreenX) {
                const newWallX = (walls.length === 0) ? maxScreenX : walls[walls.length - 1].x + 200;
                generateRandomWall(newWallX);
            }

            // Update and render the CPU characters
            cpus.forEach((cpu) => {
                cpu.update();
                cpu.draw(ctx);
            });


            bestcpu.color = 'rgba(0, 0, 255, 0.2)'; //make old best cpu bland

            bestcpu = cpus.reduce((max, cpu) => max.x > cpu.x ? max : cpu);

            //nnGraph.neuralNetwork = bestcpu.brain;
        
            bestcpu.color = 'rgba(0, 255, 255, 1)'; //hihglight new bestcpu


            if (player.x > screenX + canvas.width * 0.7) {
                screenX = player.x - canvas.width * 0.7;
            } 
        }

        // Function to check for collisions between two objects
        function isColliding(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                obj1.x + obj1.width > obj2.x &&
                obj1.y < obj2.y + obj2.height &&
                obj1.y + obj1.height > obj2.y;
        }

        // Game loop
        function gameLoop() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and render the ground
            ground.draw(ctx);

            // Update and render the Player
            updateGameElements();
            player.draw(ctx);

            // Update and render the CPU characters
            cpus.forEach((cpu) => {
                cpu.draw(ctx);
            });

            NNVis.NeuralNetwork = bestcpu.brain;

            NNVis.drawNeuralNetwork();

            setTimeout(() => {
                requestAnimationFrame(gameLoop);
            }, 1000 / 90);
        }

        // Initialize the game with initial walls
        for (let x = 200; x < 10000; x += Math.floor(Math.random() * 206) + 100) {
            generateRandomWall(x);
        }

        // Game loop initialization
        gameLoop();
    </script>
</body>
</html>
